---
title: Install Tembo Self Hosted on Azure
uppercase: false
sideBarPosition: 11
---

# Installing Tembo Self Hosted on Azure

This guide describes the steps to install Tembo Self Hosted on Azure, enabling you to deploy a high-performance, fully-extensible managed Postgres service within an Azure Kubernetes Service (AKS) cluster.

## Step 1: Obtain prerequisites

Before starting this tutorial, you must install and configure the following tools and resources necessary to create and manage Tembo Self Hosted on an Azure AKS cluster.

* The command-line tools for [Azure CLI (az)](https://docs.microsoft.com/en-us/cli/azure/install-azure-cli) and for [Kubernetes (kubectl)](https://kubernetes.io/docs/tasks/tools/).
* The [Helm CLI](https://helm.sh/docs/intro/install/).
* Obtain a [Clerk](https://clerk.com/) authentication key from Tembo.

## Step 2: Choose and set up a base domain

For the Tembo services, you will need to select a base domain, such as `tembo.mydomain.com`.

Once you have chosen your base domain, ensure you have the capacity to add and modify DNS records for it.

With this setup, your users will be able to access various subdomains to manage, monitor, and run Postgres on the platform:

* Software UI: `app.tembo.mydomain.com`
* Backend requests: `api.tembo.mydomain.com`
* Tembo Dataplane: `dataplane.tembo.mydomain.com`

## Step 3: Create an AKS control plane and a Kubernetes cluster

To create an AKS cluster named `tembo-cluster` with a minimum of three nodes, run the following command:

```shell
az aks create --resource-group myResourceGroup --name tembo-cluster --node-count 3 --node-vm-size Standard_D4s_v3 --enable-managed-identity --location eastus
```

Feel free to adjust the parameters as needed to suit your requirements.

For further information, see [Quickstart: Deploy an Azure Kubernetes Service (AKS) cluster](https://learn.microsoft.com/en-us/azure/aks/learn/quick-kubernetes-deploy-cli).

## Step 4: Install the Azure Disk CSI driver

To install the Azure Disk CSI driver, follow these steps:

1. Add the Helm repo:

```shell
helm repo add azuredisk-csi-driver https://raw.githubusercontent.com/kubernetes-sigs/azuredisk-csi-driver/master/charts
```

2. Install the Azure Disk CSI driver:

```shell
helm install azuredisk-csi-driver azuredisk-csi-driver/azuredisk-csi-driver --namespace kube-system
```

## Step 5: Install Helm dependencies

1. Install [`cert-manager`](https://github.com/cert-manager/cert-manager)

```shell
helm install \
  cert-manager jetstack/cert-manager \
  --namespace cert-manager \
  --create-namespace \
  --version v1.14.4 --set installCRDs=true
```

2. Configure [Traefik](https://github.com/traefik/traefik)

Firstly, create the `traefik` namespace:

```shell
kubectl create namespace traefik || true
```

To configure which connections Traefik should accept, create a [ConfigMap](https://kubernetes.io/docs/concepts/configuration/configmap/). If you want to accept all connections, use a ConfigMap similar to the one below:

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: postgres-catch-all
  namespace: traefik
data:
  postgres-catch-all.yaml: |
    tcp:
      routers:
        catchAll:
          entryPoints:
            - "postgresql"
          rule: "HostSNI(`*`)"
          service: empty
      services:
        empty:
          loadBalancer:
            servers: {}
```

Now, apply the ConfigMap you desire to use. If the accept-all configuration was chosen (as shown above), run:

```shell
kubectl apply -f traefik-postgres-catch-all.yaml
```

We now need to configure Traefik to handle Postgres connections appropriately. See the [example values](TODO) for reference.

Finally, install Traefik:

```shell
helm install traefik traefik/traefik --namespace traefik --version 20.8.0 -f traefik-values.yaml
```

## Step 6: Configure DNS for Traefik's Load Balancer

To properly route traffic to your Traefik load balancer, you need to configure a DNS CNAME record through your DNS provider. Follow the steps below to create a wildcard CNAME record, which is essential because each PostgreSQL instance has its own subdomain for its connection string.

1. **Access Your DNS Provider**: Log in to your DNS provider's management console.

2. **Create a Wildcard CNAME Record**: Set up a wildcard CNAME record (e.g., `*.tembo.mydomain.com`). This will cover all subdomains for your PostgreSQL instances.

3. **Use the External IP**: Point the wildcard CNAME record to the external IP of your Traefik load balancer. This external IP can be found using the command below.

```shell
kubectl get svc -n traefik
NAME      TYPE           CLUSTER-IP      EXTERNAL-IP                                                                      PORT(S)                                     AGE
traefik   LoadBalancer   10.200.50.100   abcdef1234567890abcdef1234567890-1234567890abcdef.eastus.cloudapp.azure.com   1234:56789/TCP,80:12345/TCP,443:23456/TCP   45m
```

If you're using Azure DNS, the configuration should look something like the image below. For more detailed information, refer to [Create a DNS zone and record using the Azure portal](https://docs.microsoft.com/en-us/azure/dns/dns-getstarted-portal).

4. **Verify DNS Settings**: After creating the CNAME record, verify that the DNS settings are correctly propagating and resolving.

You can use `nslookup` to check if your DNS settings are working correctly:

```shell
nslookup test.tembo.mydomain.com
Server:		8.8.8.8
Address:	8.8.8.8#53

Non-authoritative answer:
Name:	test.tembo.mydomain.com
Address: 203.0.113.10
Name:	test.tembo.mydomain.com
Address: 203.0.113.20
```

## Step 7: Update the StorageClass to allow for volume expansion

This is necessary for increasing storage size for Postgres instances.

```shell
kubectl patch storageclass default -p '{"allowVolumeExpansion": true}'
```

## Step 8: Install the Tembo Self Hosted Helm chart

Clone the Tembo Self Hosted repository:

```shell
git clone https://github.com/tembo-io/tembo-self-hosted
```

Now, within the cloned `tembo-self-hosted` directory, create a file `my-values.yaml` with the following content:

```yaml
global:
  baseDomain: tembo.mydomain.com
  monitoringEnabled: true
  conductorEnabled: false
tembo:
  cpWebserver:
    env:
      - name: STRIPE_SECRET_KEY
        value: <secret-key>
      - name: STRIPE_WEBHOOK_SIGNING_SECRET
        value: <signing-secret>
```

The base domain should be the same one created in Step 2.

Now, let's install the Tembo Self Hosted Helm chart in your AKS cluster:

```shell
helm install tembo . -f my-values.yaml -n tembo --create-namespace
```

Let's now enable the `conductor` component:

```yaml
global:
  baseDomain: tembo.mydomain.com
  monitoringEnabled: true
  conductorEnabled: true
```

Upgrade the Self Hosted Helm chart so that changes take effect:

```shell
helm upgrade tembo . -f my-values.yaml -n tembo
```
